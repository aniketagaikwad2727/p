#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

// Node structure
struct Node {
    char data;
    Node* next;
};

// Stack implemented using singly linked list
class Stack {
private:
    Node* top;

public:
    Stack() {
        top = nullptr;
    }

    bool isEmpty() {
        return top == nullptr;
    }

    void push(char val) {
        Node* temp = new Node();
        temp->data = val;
        temp->next = top;
        top = temp;
    }

    char pop() {
        if (isEmpty()) {
            throw runtime_error("Stack Underflow");
        }
        char val = top->data;
        Node* temp = top;
        top = top->next;
        delete temp;
        return val;
    }

    char peek() {
        if (isEmpty()) return '\0';
        return top->data;
    }
};

// Utility functions
int precedence(char op) {
    if (op == '^') return 3;
    if (op == '*' || op == '/') return 2;
    if (op == '+' || op == '-') return 1;
    return 0;
}

bool isOperand(char ch) {
    return isalnum(ch);
}

// Infix to Postfix
string infixToPostfix(string expr) {
    Stack s;
    string result = "";

    for (char& ch : expr) {
        if (isOperand(ch)) {
            result += ch;
        } else if (ch == '(') {
            s.push(ch);
        } else if (ch == ')') {
            while (!s.isEmpty() && s.peek() != '(') {
                result += s.pop();
            }
            if (!s.isEmpty()) s.pop(); // pop '('
        } else {
            while (!s.isEmpty() && precedence(ch) <= precedence(s.peek())) {
                result += s.pop();
            }
            s.push(ch);
        }
    }

    while (!s.isEmpty()) {
        result += s.pop();
    }

    return result;
}

// Infix to Prefix
string infixToPrefix(string expr) {
    reverse(expr.begin(), expr.end());
    for (int i = 0; i < expr.length(); i++) {
        if (expr[i] == '(') expr[i] = ')';
        else if (expr[i] == ')') expr[i] = '(';
    }

    string postfix = infixToPostfix(expr);
    reverse(postfix.begin(), postfix.end());
    return postfix;
}

// --------------------- Main ---------------------
int main() {
    string infix;
    cout << "Enter infix expression (e.g., a+(b*c)^d-e): ";
    getline(cin, infix);

    try {
        string postfix = infixToPostfix(infix);
        string prefix = infixToPrefix(infix);

        cout << "\nPostfix: " << postfix << endl;
        cout << "Prefix : " << prefix << endl;
    } catch (exception& e) {
        cout << "Error: " << e.what() << endl;
    }

    return 0;
}
